# ZK-VCR Smart Contract

This directory contains the core on-chain logic for the ZK-VCR project, written in the Compact language. It defines the smart contract, the Zero-Knowledge circuits, and the data structures that govern the entire DApp.

## File Structure

-   `src/zk_vcr.compact`: This is the most important file. It contains the complete source code for the smart contract, including:
    -   **Ledger State:** The on-chain database schema (`owner`, `trustedIssuers`, `usedNonces`).
    -   **ZK Circuits:** The definitions for all public-facing functions (`addIssuer`, `revokeIssuer`, `submitHealthProof`, `getChallenge`).
    -   **Helper Circuits:** Internal pure functions for complex logic (`derivePublicKey`, `checkSignature`, `calculateRisk`).
-   `src/witnesses.ts`: Defines the TypeScript types for the private data that is passed from the off-chain world into the ZK circuits. This acts as a bridge between the CLI and the contract.
-   `src/managed/`: This directory is automatically generated by the `compactc` compiler. It contains the JavaScript/TypeScript bindings for the contract, compiled circuit artifacts (ZKIR), and proving/verifying keys. **You should not edit files in this directory.**
-   `package.json`: Defines the project's dependencies and scripts, most notably the `npm run compact` command which compiles the `zk_vcr.compact` file.

## Code Flow

The smart contract's logic is divided into three main categories:

1.  **Constructor:** When the contract is first deployed, the `constructor` runs once. It takes the deployer's secret key, derives a public key from it, and permanently stores that public key in the `owner` ledger variable. This establishes the "master key" for the DApp.

2.  **Administrative Circuits (`addIssuer`, `revokeIssuer`):** These are protected functions.
    -   A transaction calls one of these circuits.
    -   The circuit demands the `ownerSecretKey` as a private witness.
    -   It derives a public key from the provided secret key.
    -   It then **asserts** that the derived public key matches the `owner` public key stored in the ledger.
    -   If the assertion passes, it proceeds to modify the `trustedIssuers` map. If it fails, the transaction aborts.

3.  **Public User Circuit (`submitHealthProof`):** This is the main ZK circuit for users.
    -   The user's CLI first calls the `getChallenge` circuit to receive a unique, single-use nonce.
    -   The user then calls `submitHealthProof`, providing the issuer's public key and the challenge as public inputs.
    -   The circuit demands the user's `VerifiableCredential` as a private witness.
    -   It performs a series of **assertions**:
        1.  Is the issuer's key in the `trustedIssuers` registry?
        2.  Is the issuer currently trusted (i.e., not revoked)?
        3.  Has the challenge nonce already been used?
        4.  Is the signature on the credential valid?
        5.  Does the health data in the credential meet the risk model's criteria?
    -   If all assertions pass, the circuit succeeds and adds the challenge nonce to the `usedNonces` map to prevent replay attacks. If any assertion fails, the entire transaction aborts.

<details>
<summary><strong>Common On-Chain Errors (Assertions)</strong></summary>

*   **`failed assert: Caller is not the owner`**
    *   **Reason:** The secret key provided to an administrative circuit (`addIssuer`, `revokeIssuer`) did not match the owner's key stored on-chain.

*   **`failed assert: Issuer key not found in registry`**
    *   **Reason:** The `submitHealthProof` circuit was called with an `issuerKey` that has not been added to the `trustedIssuers` map by the administrator.

*   **`failed assert: Issuer is not trusted`**
    *   **Reason:** The `issuerKey` provided is in the registry, but its value is set to `false`, meaning the administrator has revoked its trust.

*   **`failed assert: Challenge nonce has already been used`**
    *   **Reason:** The proof was submitted with a challenge value that has already been recorded in the `usedNonces` map from a previous successful submission. This is a successful replay attack prevention.

*   **`failed assert: VC signature is invalid`**
    *   **Reason:** The cryptographic signature in the user's private `credential.json` does not match the expected signature calculated from the health data and the issuer's public key. This means the credential is fraudulent or was tampered with.

*   **`failed assert: Health risk score does not meet criteria`**
    *   **Reason:** The signature and issuer are valid, but the health data within the credential (e.g., cholesterol level) does not pass the logic defined in the `calculateRisk` circuit.

</details>

## Development History

The smart contract was developed in iterative phases. You can review the pull requests for each phase to see how the code evolved:

*   **[Phase 1: Smart Contract Skeleton](https://github.com/SarthakB11/zk-vcr/commit/d920b19711074c47ee4e70dfbd84f33dd4d96255)**: Details the implementation of the on-chain governance and security model.
*   **[Phase 2: Core ZK Logic](https://github.com/SarthakB11/zk-vcr/pull/1)**: Explains the implementation of the ZK circuits for signature verification and the AI model.
*   **[Phase 4: Final UX & Security Hardening](https://github.com/SarthakB11/zk-vcr/pull/3)**: Details the final CLI enhancements and the implementation of the challenge-response mechanism.
